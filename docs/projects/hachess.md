# hachess

<div align="center" id="top">
  <img src="https://media4.giphy.com/media/Spty0N8Cg3lNMnFLoB/giphy.gif" width="256" alt="hachess"/>
</div>

<div align="center">
  <a href="https://github.com/tesseract-blue/hachess" rel="nofollow">
    <img src="https://img.shields.io/github/stars/tesseract-blue/hachess" alt="Stars">
  </a>
  <a href="https://github.com/tesseract-blue/hachess/blob/main/LICENSE">
    <img alt="license" src="https://img.shields.io/badge/license-MIT-blue" />
  </a>

</div>

A friend and I decided to start a competition to create chess-playing agents and compete with them, testing different strategies and algorithms. We created a library to facilitate the competition and published it for others to use in similar competitions. The only libraries we allowed ourselves to use were numpy for numerical calculations and python-chess as the representation of the ruleset.

The exponential nature of computer chess causes your code to quickly run into computational limits and the need for optimization. The sheer complexity of the game meant that even the smallest improvements in our code could lead to significant enhancements in performance. Balancing the tradoffs between depth and evaluation function accuracy was a constant challenge.